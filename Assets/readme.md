# Graph-Based Dungeon Generator (Nepožitek, Part 1–2) — Unity + Tilemap + DoorSocket + “edge-rooms”

README описывает **полный алгоритм** из двух статей (граф, конфигурационные пространства, планарное разложение на chain’ы, инкрементальная укладка, simulated annealing) и добавляет **наши проектные уточнения** для Unity/Tilemap:  
- у комнат и коридоров есть **DoorSocket** с направлением **N/E/S/W**,  
- **каждое ребро** исходного графа превращается в отдельную **комнату-коридор** со своими шаблонами,  
- коридорная комната **“вгрызается” в обычную на 1 тайл** при стыковке.

---

## 0) Что делает алгоритм (цель)

Вход:
1) Набор **room templates** (в оригинале — полигоны/“building blocks”), у каждого есть допустимые места дверей. :contentReference[oaicite:0]{index=0}  
2) **Граф связности** (level topology): вершины — комнаты, рёбра — требования “эти комнаты должны соединяться дверью”. :contentReference[oaicite:1]{index=1}

Выход:
- для каждой вершины: выбранный шаблон + позиция,
- выполняется: **комнаты не пересекаются**, и **каждая пара соседей по графу может быть соединена дверями**. :contentReference[oaicite:2]{index=2}

---

## 1) Проектные уточнения (Unity/Tilemap, обязательные)

### 1.1. Все рёбра — это тоже “комнаты” (corridor-room)
В статьях для коридоров предлагается модификация: вставлять новую вершину между соседними комнатами и считать её “corridor room” со своими shapes/door positions. :contentReference[oaicite:3]{index=3}  
Мы делаем это всегда:

Для каждого ребра `(u, v)` исходного графа создаём `c(u,v)` типа `CorridorRoom` и заменяем ребро на:
- `(u, c(u,v))`
- `(c(u,v), v)`

Итоговый граф укладываем целиком.

### 1.1.1. Валидные соединения только Room ↔ CorridorRoom
После преобразования графа все соединения происходят **только** между обычной комнатой и corridor-room:
- в итоговом графе **не существует** рёбер `Room–Room`,
- в итоговом графе **не существует** рёбер `CorridorRoom–CorridorRoom`.

Это сознательное ограничение дизайна: corridor-room всегда используется как “edge-room” для конкретного исходного ребра.

### 1.2. DoorSocket (N/E/S/W)
У **каждого шаблона** (и комнат, и коридоров) есть `DoorSocket`:

- `localCell: Vector2Int` — координата сокета в локальной маске шаблона (тайл)
- `dir ∈ {North, East, South, West}` — направление “наружу”
- (пока что) ширина проёма **не поддерживается**, считаем всегда `width = 1`

Стыковка возможна только если направления противоположны (`opposite`).

### 1.3. “Вгрызание” коридора на 1 тайл
Для связи **Room ↔ CorridorRoom** требуем, чтобы:
- world-клетка выбранного room-socket **совпала** с world-клеткой выбранного corridor-socket, и
- `dirCorridor = opposite(dirRoom)`.

То есть коридорная комната **заходит внутрь комнаты на 1 клетку**: этот тайл считается “общим проёмом”.

**Важно для валидности:** пересечение Room и CorridorRoom разрешено **только** на этой одной клетке сокета (см. раздел 6).

### 1.3.1. Carve-mask у входа коридора (практическая доработка под тайлы/стены)
В наших префабах коннектор обычно выглядит как “проход шириной 1 тайл + стены по бокам”, то есть имеет **wall-полосы рядом с дверным проёмом**.
Если считать стены “жёсткой геометрией”, то при байте эти боковые стенки часто конфликтуют с полом комнаты возле входа.

Поэтому мы вводим маленькую “маску выреза” на стороне коннектора:
- на **bite cell** допускается стык/пересечение по правилам 1.3,
- дополнительно, **две боковые wall-клетки коннектора**, соседние с bite cell **перпендикулярно направлению сокета**, считаются “вырезанными” (как будто комната их сносит).

Эта carve-mask учитывается:
- при предвычислении configuration spaces (смещения не отбрасываются из‑за этих двух клеток),
- при проверках валидности/энергии,
- на этапе placement (эти клетки реально удаляются из набора `occupiedWall` коннектора перед коммитом).

---

## 2) Представление шаблонов под Tilemap

В оригинале формы — полигоны. :contentReference[oaicite:4]{index=4}  
В Unity-версии удобно и обычно быстрее делать дискретную модель:

### 2.1. Структура префабов Room и CorridorRoom (Connector)
В реализации геометрия шаблонов берётся **не из ScriptableObject**, а прямо из **префабов** (инстанцируются на сцене для анализа).

**Общее для любых модулей (Room и CorridorRoom):**
- на корне префаба должен быть `ModuleMetaBase` (`Assets/scripts/ModuleMetaBase.cs`),
- сокеты можно задавать двумя способами:
  - вручную: в `ModuleMetaBase.Sockets` перечислить `DoorSocket` дочерние объекты,
  - полуавтоматически: добавить `DoorSocketSpan` на стену (см. ниже) и оставить `ModuleMetaBase.AutoCollectSockets = true` (по умолчанию),
- `DoorSocket` задаёт:
  - `Side ∈ {North,East,South,West}` — направление “наружу”,
  - `Width` сейчас всегда `1` (зафиксировано кодом),
- внутри префаба должны быть дочерние `Tilemap`:
  - для пола — имя `GameObject` содержит `"floor"` (case-insensitive),
  - для стен — имя `GameObject` содержит `"wall"` (case-insensitive),
  - именно эти тайлы используются для `footprint/overlap` и для финального bake.

**Room prefab (вершина-графа):**
- компонент на корне: `RoomMeta : ModuleMetaBase` (`Assets/scripts/RoomMeta.cs`),
- количество сокетов: `0..N` (по дизайну/шаблону),
- важно: клетка сокета должна быть частью пола комнаты (иначе строгий “bite” не сработает).

**CorridorRoom prefab (edge-room, вставленная вершина):**
- компонент на корне: `ConnectorMeta : ModuleMetaBase` (`Assets/scripts/ConnectorMeta.cs`),
- обычно 2 сокета (вход/выход), чтобы соединяться с двумя комнатами,
- по дизайну **не соединяется** с другим `ConnectorMeta` (только `RoomMeta ↔ ConnectorMeta`).

**Ключевой нюанс “1-tile bite”:**
- Room и CorridorRoom при стыковке должны иметь **ровно 1 общую клетку** — это клетка, в которой стоит `DoorSocket` на обоих концах ребра,
- поэтому `DoorSocket` должен быть размещён в центре клетки Grid, и эта клетка должна существовать как “пол” в обоих модулях.

Примечание для текущей реализации: у Room префабов клетка сокета может визуально быть стеной; при вычислении геометрии она всё равно считается “проёмной” (как пол) по факту наличия `DoorSocket`.

### 2.2. DoorSocketSpan (дискретный “радиус” по стене, чтобы не проставлять много сокетов руками)
Если проставлять много `DoorSocket` руками неудобно, используйте `DoorSocketSpan` (`Assets/scripts/DoorSocketSpan.cs`):
- это компонент-маркер (обычно дочерний объект комнаты/коннектора) с полями:
  - `Side` — направление наружу,
  - `Radius` — сколько тайлов влево/вправо (по касательной к стене) разрешены как точки стыка, `0` = одна точка,
- `DoorSocketSpan` **автоматически генерирует** дочерние `DoorSocket` точки с шагом 1 тайл вдоль стены:
  - для `North/South` — меняется `X`,
  - для `East/West` — меняется `Y`,
- важно: сам `DoorSocketSpan` должен стоять в центре клетки Grid (как обычный сокет), а `Radius` задаёт дискретные варианты стыковки.

**RoomTemplate (ScriptableObject):**
- `HashSet<Vector2Int> footprintCells` — какие тайлы занимает (пол)
- `List<DoorSocket> sockets`
- (опционально) данные для отрисовки: floor/wall/decoration правила

Позиция инстанса шаблона в мире:
- `origin: Vector3Int` (якорь в Grid)
- `worldCell = origin + localCell`

---

## 3) Конфигурационные пространства (Configuration Spaces)

### 3.1. Определение (как в статьях)
Для пары форм (одна фиксирована, другая движется) configuration space — множество позиций движущейся формы, при которых формы **не пересекаются** и **могут быть соединены дверью**. :contentReference[oaicite:5]{index=5}  
Для нескольких соседей берётся **пересечение** их конфигурационных пространств. :contentReference[oaicite:6]{index=6}

### 3.2. Как используется (2 применения из статей)
1) Не выбирать позицию комнаты случайно, а искать такую, которая удовлетворяет **максимум соседей**, через (максимальное) непустое пересечение CS. :contentReference[oaicite:7]{index=7}  
2) Проверять валидность: позиция комнаты должна лежать в CS относительно всех соседей. :contentReference[oaicite:8]{index=8}

### 3.3. Предвычисление (как в статьях)
Так как shapes не меняются во время работы, CS можно **предвычислить для всех пар shapes** до запуска оптимизации. :contentReference[oaicite:9]{index=9}

### 3.4. CS в нашей Tilemap+DoorSocket постановке (дискретно)
Мы определяем CS как набор смещений `delta` (Vector2Int) для пары шаблонов `(A, B)`:

`delta` допустим, если существует пара сокетов `(sA, sB)`:
- `dir(sB) = opposite(dir(sA))`
- и при размещении `originB = originA + (sA.localCell - sB.localCell)`:
  - пересечения клеток разрешены по правилам (обычно 0, а для Room–Corridor допускается 1 клетка сокета),
  - достигается требуемая стыковка (см. 1.3).

Результат: CS — это конечное множество `delta`, его легко хранить и пересекать.

---

## 4) Почему нужен планарный граф и разложение на chain’ы

### 4.1. Инкрементальная укладка вместо “всех сразу”
Статья прямо говорит: полный перебор неэффективен; вместо этого поиск направляется CS и оптимизируется, а ещё задача делится на подзадачи — граф раскладывается частями (chains). :contentReference[oaicite:10]{index=10}

### 4.2. Incremental layout + backtracking (как в статье)
Алгоритм держит стек частичных раскладок:
- берём последнюю partial layout,
- выбираем следующую chain, которая присоединяется к уже уложенным вершинам,
- `AddChain()` пытается расширить раскладку и возвращает **несколько** вариантов,
- если расширить нельзя — откатываемся (backtracking) к другой partial layout. :contentReference[oaicite:11]{index=11}  
Несколько вариантов нужны именно чтобы было “куда откатываться”. :contentReference[oaicite:12]{index=12}

---

## 5) Chain decomposition через планарное вложение (planar embedding)

Статья: чтобы разложить граф на chains, нужно найти **planar embedding** (рисунок графа на плоскости без пересечений рёбер, кроме концов), затем извлечь **faces**. :contentReference[oaicite:13]{index=13}

Логика порядка:
- циклы “жёстче” (больше ограничений), поэтому их стараются обрабатывать раньше, уменьшая шанс позднего backtracking. :contentReference[oaicite:14]{index=14}  
Правило построения:
1) первая chain = **самая маленькая face**,
2) дальше добавляем faces в **BFS-порядке** по adjacency faces; если есть выбор — берём меньшую,
3) когда faces закончились — добавляем оставшиеся **ацикличные компоненты**. :contentReference[oaicite:15]{index=15}

---

## 6) Simulated Annealing внутри AddChain()

Статья: simulated annealing (SA) используется для эффективного исследования пространства раскладок. :contentReference[oaicite:16]{index=16}

### 6.1. Что меняем на шаге (PerturbLayout)
SA шаг: случайно выбираем вершину chain и меняем:
- либо **shape** (случайный из доступных), :contentReference[oaicite:17]{index=17}
- либо **position**.

Ключевое: позицию не стоит выбирать случайно, иначе энергия часто ухудшается и сходимость падает; позицию выбирают через **configuration spaces**, чтобы удовлетворить как можно больше соседей. :contentReference[oaicite:18]{index=18}

### 6.2. Энергия (как в статье)
Энергия penalizes:
- пересечения,
- и соседей по графу, которые не в контакте. :contentReference[oaicite:19]{index=19}  

В статье:
- `A` = суммарная площадь пересечения всех пар блоков,
- `D` = сумма квадратов расстояний между центрами соседних по графу блоков, которые **не в контакте**,
- `ω` выводится из средней площади блоков и влияет на “готовность” принимать худшие решения. :contentReference[oaicite:20]{index=20}

**Наша Tilemap адаптация (эквивалент смыслу):**
- `A_tiles` = суммарное число пересечённых клеток (кроме разрешённых 1-tile bite),
- `D_tiles` = сумма квадратов расстояний между “центрами” (например, среднее footprintCells) для пар соседей, которые не состыкованы через sockets.

### 6.3. Правило принятия (как в статье)
- если новая раскладка лучше по энергии — принять,
- иначе — принять с некоторой вероятностью,
- вероятность принимать худшее уменьшается со временем. :contentReference[oaicite:21]{index=21}

---

## 7) AddChain(): полный процесс (как в статье)

Псевдокод в статье:
- `currentLayout = GetInitialLayout(layout, chain)`
- повторяем (внешний цикл) генерацию кандидатов, а внутри (внутренний цикл) делаем SA-итерации:
  - `newLayout = PerturbLayout(currentLayout, chain)`
  - если `IsValid(newLayout)` и `DifferentEnough(...)` → сохраняем как один из результатов
  - обновляем `currentLayout` по правилу энергии/вероятности
  - “cool down” между внешними итерациями :contentReference[oaicite:22]{index=22}

### 7.1. GetInitialLayout(): greedy и BFS (как в статье)
Чтобы стартовать с низкой энергией:
- строится BFS-порядок вершин chain, начиная с вершин, соседних с уже уложенными,
- вершины размещаются по одной, выбирая позицию из CS с **минимальной энергией**,
- без backtracking (жадно). :contentReference[oaicite:23]{index=23}

### 7.1.1. Практическая доработка: кандидаты позиций не фильтруются по пересечениям
Чтобы SA мог “пропихивать” сложные циклы, мы **не отбрасываем** кандидатные позиции только из‑за пересечений на этапе генерации кандидатов.
Пересечения штрафуются энергией, а строгая валидность проверяется **только** когда сохраняем один из результатов `AddChain()`.

### 7.2. DifferentEnough()
Статья использует фильтр “DifferentEnough” для разнообразия сохранённых partial layouts, деталей метрики не фиксирует. :contentReference[oaicite:24]{index=24}  
Для реализации в Tilemap можно выбрать простую метрику различия (например по origins / bounding boxes / выбору shapes), но это уже решение проекта.

---

## 8) IsValid() в нашей постановке (строго)

Статья: валидность проверяется, в том числе, через CS: позиция комнаты должна “принадлежать” CS всех соседей. :contentReference[oaicite:25]{index=25}  
Мы фиксируем конкретно под Tilemap+DoorSocket:

### 8.1. Пересечения
С учётом ограничения 1.1.1 реально рассматривается только пара **Room–Corridor**.

Правила (тайловая модель):
- **Floor↔Floor**: запрещено, кроме ровно **1 клетки** (bite cell) на удовлетворённом ребре.
- **Wall↔Floor**: запрещено, кроме разрешённых carve-зон (см. 1.3.1):
  - bite cell,
  - + две боковые wall-клетки коннектора у входа (tangent‑соседи bite cell).

### 8.2. Стыковка рёбер графа
Для каждого ребра `(a, b)` итогового графа:
- существует пара сокетов `(sa, sb)`:
  - `dir(sb) = opposite(dir(sa))`
  - и выполнено правило геометрии:
    - для Room–Corridor (наш основной случай): `worldCell(sa) == worldCell(sb)` (bite-тайл)
    - `Room–Room` и `Corridor–Corridor` соединения по дизайну **не допускаются** (см. 1.1.1)

---

## 9) Bake в Unity Tilemap (после получения layout)

Рекомендуемые слои:
- `FloorTilemap`, `WallTilemap`, `DoorTilemap` (+ Decor опционально)

Процесс:
1) очистить слои,
2) для каждого инстанса шаблона:
   - проставить floor по `footprintCells`,
   - построить walls по границе footprint (клетки-соседи снаружи),
3) для каждого ребра:
   - поставить door tile в world-cell стыка (тот самый bite-тайл),
   - при необходимости спавнить door prefab поверх.

---

## 10) Мини-чеклист “алгоритм полностью учтён”

- [ ] Вход: templates + граф; выход: shape+position для каждой вершины. :contentReference[oaicite:26]{index=26}
- [ ] Corridors реализованы как вставка node между соседями (edge-room). :contentReference[oaicite:27]{index=27}
- [ ] Configuration spaces: определение, пересечения для нескольких соседей, 2 применения, предвычисление. :contentReference[oaicite:28]{index=28}
- [ ] Incremental layout: stack partial layouts + backtracking + несколько расширений. :contentReference[oaicite:29]{index=29}
- [ ] Chain decomposition: planar embedding → faces; порядок: smallest face → BFS faces → остаток acyclic. :contentReference[oaicite:30]{index=30}
- [ ] AddChain: initial greedy BFS; SA: perturb node (shape/pos), энергия с A и D, принятие с вероятностью, cooling. :contentReference[oaicite:31]{index=31}
- [ ] Проектные детали: DoorSocket N/E/S/W + bite на 1 тайл + разрешённое пересечение только на socket-cell (это уже наши требования).
