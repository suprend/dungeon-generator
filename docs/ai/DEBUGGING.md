# Дебаг‑гайд

Практический чеклист по типовым проблемам генератора.

## Какие логи смотреть

- `[MapGraphLevelSolver] Timings (s): ...`
  - Разрез времени: `precompute`, `solve`, `layout`, `place`, `stamp`.
- `[ConfigSpace] Empty offsets for A -> B`
  - Для пары префабов configuration space (CS) пустое (нет допустимых смещений).
- `[ConfigSpace][dbg] ... => reject ...`
  - Детальная причина, почему конкретная пара сокетов/дельта отбрасывается (включается verbose).
- `[LayoutGenerator] ...`
  - Ошибки генерации кандидатов (`No position candidates`) или провалы `AddChain`.
- `Last failure: Global invalid: disconnected layout ...`
  - Layout найден, но итоговая раскладка не связная (не все комнаты достижимы по “состыкованным” рёбрам).

## Частые причины и что делать

### 1) `Empty offsets for room -> connector`
Типовые причины:
- сокетов нет или направление не совпадает (не opposite)
- сокет стоит “не там” (смещение относительно floor/wall клеток не соответствует правилам)
- на входе конфликтуют стены/пол из‑за того, что carve‑mask / bite‑depth не применяется/не учитывается

Что делать:
- включить verbose CS logs и посмотреть первую причину reject
- проверить префаб: сокеты стоят в центрах клеток, `DoorSide` корректный
- проверить, что у коннектора физически есть вход, который может “вкусить” комнату
- отдельно проверить BiteDepth:
  - `DoorSocket.BiteDepth` на сокете коннектора должен быть >= 1
  - `depthX` в логах (`accept depthX=...`) должен быть < BiteDepth
  - если видишь `reject ... door not on floor`, значит в выбранной door‑cell нет floor в одном из shape’ов

### 2) Layout не строится на части seed
Типовые причины:
- мало вариантов сокетов (низкая степень свободы)
- слишком маленький бюджет SA (cycles требуют больше поиска)
- генерация кандидатов фильтрует слишком жёстко на ранней стадии

Что делать:
- проверить `MaxLayoutsPerChain`, `TemperatureSteps`, `InnerIterations`
- держать per‑step проверки дешёвыми; строгую валидацию делать только при сохранении результата
- вместо ручного “много сокетов” использовать `DoorSocketSpan`

### 3) Placement падает после успешного layout (overlaps)
Типовые причины:
- layout‑валидация “разрешает” то, что placement запрещает (или наоборот)
- carve‑mask применяется в одном месте, но не применяется в другом

Что делать:
- убедиться, что правила bite/carve одинаковы в:
  - CS computation
  - layout overlap penalty/validation
  - placement overlap checks

### 4) “В месте двери стена/дырка вместо пола”
Симптомы:
- Layout/CS принимает `depthX`, но в итоговой штамповке в door‑cell нет прохода.

Ключевой инвариант:
- Сокет комнаты часто авторится в стене, но когда ребро реально используется, в `door cell` должен быть проход.
- Поэтому в layout/energy/validation допускается ровно одно пересечение `wall(room)` на `floor(connector)` в door‑cell.

Что делать:
- проверить, что room prefab действительно имеет floor в door‑cell (часто floor есть “под стеной”)
- проверить, что carve‑mask учитывается одинаково в layout и placement

## Минимальный “repro bundle” для ИИ

Для бага/перф‑проблемы приложить:
- размер графа и seed
- строку таймингов
- первые `[ConfigSpace]` / `[LayoutGenerator]` warnings
- 1–2 скрина префабов (room + connector) с сокетами и floor/wall Tilemap
